#include "oled.h"#include "oledfont.h"#include "delay.h"#include "string.h"/* * <<128*64 OLED>> * * note：DMA每次传输128*64个字节需要花费约20ms(72M主频), 在此期间进行其他I2C操作都会进入BUSY等待状态 *		 DMA搬运完成前对数据进行clear会导致图像残缺，故采用双缓存操作，防止数据意外串改 * 		 OLED_Refresh函数(该函数执行周期不到1ms)调用周期>=20ms, 确保CPU资源不处于I2C的BUSY等待中 * 	 	 DMA搬运依然会遵守I2C序列, 故传输时间不会有明显的缩短, 但此期间CPU资源不被占用 *  * 帧率计算(72M主频)：参数设置为I2C_DutyCycle_16_9 + 400000, 使用逻辑分析仪实际测出的频率已超频到450KHz(忙猜是ST时钟分频不准) * 		 450000/(8*1024) = 55帧; 1000/55 = 18ms, 即DMA每搬运1024个字节需18ms, 再加上等待ack的时间, 20ms差不多 */ /* * 待优化： * 1.目前无法在任意时刻去调用带有OLED_WR_CMD的函数，否则都将可能造成资源浪费 * 2.暂不支持一次I2C时序发送多个命令 * 3.暂未固定刷新周期（需要结合定时器） * 4.部分函数未整理 * 5.API函数不能只局限于128*64的分辨率 * 6.未做设备检测和断开检测 */uint8_t OLED_GRAM[8][128];#ifdef USE_DMA	uint8_t TEMP_GRAM[8][128]; /* Actual transfer cache */#endif#ifdef USE_HARD_I2C/* * I2C init */void i2c_init(void){/* * PB6 - IIC1 SCL * PB7 - IIC1 SDA */	/* GPIO */	GPIO_InitTypeDef GPIO_InitStruct;	 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);		GPIO_InitStruct.GPIO_Pin  	= GPIO_Pin_6|GPIO_Pin_7;	  	GPIO_InitStruct.GPIO_Mode 	= GPIO_Mode_AF_OD; /* OD */	GPIO_InitStruct.GPIO_Speed	= GPIO_Speed_50MHz; 	GPIO_Init(GPIOB, &GPIO_InitStruct);		/* I2C */	I2C_InitTypeDef  I2C_InitStruct;		RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,ENABLE);		I2C_InitStruct.I2C_ClockSpeed 	= I2C_SPEED; /* >100KHz:Fm mode otherwise in Sm mode*/	I2C_InitStruct.I2C_Mode			= I2C_Mode_I2C;	I2C_InitStruct.I2C_DutyCycle	= I2C_DutyCycle_16_9; /* valid in fm mode(>100KHz) Controls the SCL clock Thigh and Tlow in master mode */	I2C_InitStruct.I2C_OwnAddress1	= 0x00;	/* no used in master mode */	I2C_InitStruct.I2C_Ack			= I2C_Ack_Enable;	I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;	I2C_Init(I2C1, &I2C_InitStruct);		#ifdef USE_DMA		/* I2C1_TX - DMA_CH6 */		DMA_InitTypeDef  DMA_InitStruct;		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);				DMA_InitStruct.DMA_BufferSize 			= sizeof(TEMP_GRAM); /* 1024Bytes */		DMA_InitStruct.DMA_DIR 					= DMA_DIR_PeripheralDST;		DMA_InitStruct.DMA_M2M 					= DMA_M2M_Disable;		DMA_InitStruct.DMA_MemoryBaseAddr 		= (u32)&TEMP_GRAM;		DMA_InitStruct.DMA_MemoryDataSize 		= DMA_MemoryDataSize_Byte;		DMA_InitStruct.DMA_MemoryInc			= DMA_MemoryInc_Enable;		DMA_InitStruct.DMA_Mode 				= DMA_MODE;		DMA_InitStruct.DMA_PeripheralBaseAddr 	= (u32)&I2C1->DR;		DMA_InitStruct.DMA_PeripheralDataSize 	= DMA_PeripheralDataSize_Byte;		DMA_InitStruct.DMA_PeripheralInc		= DMA_PeripheralInc_Disable;		DMA_InitStruct.DMA_Priority 			= DMA_Priority_VeryHigh;		DMA_Init(DMA1_Channel6, &DMA_InitStruct);				DMA_ITConfig(DMA1_Channel6,DMA_IT_TC,ENABLE);				NVIC_InitTypeDef NVIC_InitStruct;		NVIC_InitStruct.NVIC_IRQChannel		=DMA1_Channel6_IRQn;		NVIC_InitStruct.NVIC_IRQChannelCmd	=ENABLE;		NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority	= 2;		NVIC_InitStruct.NVIC_IRQChannelSubPriority			= 2;		NVIC_Init(&NVIC_InitStruct);				DMA_Cmd(DMA1_Channel6, ENABLE);	#endif}/* * I2C send cmd  */void oled_send_cmd(uint8_t cmd){	/* BUSY */	while(I2C1->SR2 & 0x2);		/* START - EV5 */	I2C1->CR1 |= (1 << 8);	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));		/* SEND ADDR - EV6 */	I2C1->DR = OLED_ADDR|I2C_Direction_Transmitter;	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));		/* CMD */	I2C1->DR = OLED_CMD;	while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));		/* SEND CMD */	I2C1->DR = cmd;	while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));		/* STOP */	I2C1->CR1 |= (1 << 9);}#endif /* USE_HARD_I2C *//* * set contrast * range 0-255 */void OLED_Set_Contrast(uint8_t level){	OLED_WR_CMD(0x81);	OLED_WR_CMD(level);}/* * set display mode * mode1:  * 		0-follows RAM content * 		1-Entire display ON * mode2: * 		0-Normal  display(1 in RAM: ON  in display panel) * 		1-Inverse display(1 in RAM: OFF in display panel) */void OLED_Set_Disp_Mode(uint8_t mode1, uint8_t mode2){	OLED_WR_CMD(0xA4|mode1);	OLED_WR_CMD(0xA6|mode2);}/* * oled on */void OLED_On(void){	OLED_WR_CMD(0x8D);	OLED_WR_CMD(0x14);	OLED_WR_CMD(0xAF);}/* * oled off */void OLED_Off(void){	OLED_WR_CMD(0x8D);	OLED_WR_CMD(0x10);	OLED_WR_CMD(0xAF);}/* * turn upside down * 0-off * 1-on */void OLED_UD_Turn(uint8_t state){	OLED_WR_CMD(0xC0|(state<<3));}/* * Turn around * 0-off * 1-on */void OLED_LR_Turn(uint8_t state){	OLED_WR_CMD(0xA0|state);}/*  * 0-Horizontal Addressing Mode * 1-Vertical   Addressing Mode * 2-Page 	   	Addressing Mode */void OLED_Set_Memory_Addr_Mode(uint8_t mode){	OLED_WR_CMD(0x20);	OLED_WR_CMD(mode);}/* * set colu addr(for Page Addressing Mode) * range 0-127 */void OLED_Set_Colu_Start_Addr(uint8_t addr){	OLED_WR_CMD(0x00|(addr%16));	OLED_WR_CMD(0x10|(addr/16));}/* * set page addr(for Page Addressing Mode) * range 0-7 */void OLED_Set_Page_Start_Addr(uint8_t page){	OLED_WR_CMD(0xB0|page);}/* * Sets the column address display range(for Horizontal/Vertical Addressing Mode) * range 0-127 */void OLED_Set_Colu_Range(uint8_t start, uint8_t end){	OLED_WR_CMD(0x21);	OLED_WR_CMD(start);	OLED_WR_CMD(end);}/* * Sets the page address display range(for Horizontal/Vertical Addressing Mode) * range 0-7 */void OLED_Set_Page_Range(uint8_t start, uint8_t end){	OLED_WR_CMD(0x22);	OLED_WR_CMD(start);	OLED_WR_CMD(end);}/* * set start line * range 0-63 */void OLED_Set_Start_Line(uint8_t line){	OLED_WR_CMD(0x40|line);}/* * Scroll left and right Settings * range 1-8(1 is the fastest) */void OLED_LR_Scroll(uint8_t page_start, uint8_t page_end, uint8_t dir, uint8_t speed){	uint8_t Speed;		switch(speed)	{		case 1: Speed = 7;break;		case 2: Speed = 4;break;		case 3: Speed = 5;break;		case 4: Speed = 0;break;		case 5: Speed = 6;break;		case 6: Speed = 1;break;		case 7: Speed = 2;break;		case 8: Speed = 3;break;	}		OLED_WR_CMD(0x2E);	OLED_WR_CMD(0x29+dir);	OLED_WR_CMD(0x00);		OLED_WR_CMD(page_start);	OLED_WR_CMD(Speed);	OLED_WR_CMD(page_end);		OLED_WR_CMD(0x00);	OLED_WR_CMD(0x2F);}/* * Scroll to open */void OLED_Scroll_On(void){	OLED_WR_CMD(0x2F);}/* * Rolling off */void OLED_Scroll_Off(void){	OLED_WR_CMD(0x2E);}/* * oled init */void oled_init(void){	#ifdef USE_HARD_I2C		i2c_init();	#else			#endif		delay_ms(50);		/****************CONFIGURATION****************/	OLED_Off();		OLED_Set_Contrast(255);		OLED_UD_Turn(1);	OLED_LR_Turn(1);		OLED_Set_Disp_Mode(0,0);		OLED_Set_Memory_Addr_Mode(0);		/* for Page Addressing Mode */	OLED_Set_Colu_Start_Addr(0);	OLED_Set_Page_Start_Addr(0);		/* Horizontal/Vertical Addressing Mode */	OLED_Set_Colu_Range(0,127);	OLED_Set_Page_Range(0,7);		OLED_Set_Start_Line(0);		OLED_On();	/********************************************/		OLED_Clear_GRAM();	OLED_Refresh();		delay_ms(20);}#ifdef USE_DMAuint8_t DMA_working = 0; /* when open DMA transfer it will be set to 1 *//* * DMA interrupt handler */void DMA1_Channel6_IRQHandler(void){	if(DMA_GetFlagStatus(DMA1_FLAG_TC6) != 0)	{		DMA_ClearFlag(DMA1_FLAG_TC6);				I2C_DMACmd(I2C1,DISABLE);				/* Wait for the last data transfer to complete */		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));				/* stop */		I2C1->CR1 |= (1 << 9);		DMA_working = 0;	}}#endif/* * The whole screen fill (128*64) */void OLED_Fill(void){#ifdef USE_HARD_I2C	/* BUSY */	while(I2C1->SR2 & 0x2);		/* START - EV5 */	I2C1->CR1 |= (1 << 8);	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));	/* SEND ADDR - EV6 */	I2C1->DR = OLED_ADDR|I2C_Direction_Transmitter;	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));	/* SEND CMD DATA OR CMD */	I2C1->DR = OLED_DATA;	while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));		#ifdef USE_DMA		/* Circular mode */		if(DMA1_Channel6->CCR & (1 << 5));		/* normal mode */		else		{			/* reload transfer data counter */			DMA_Cmd(DMA1_Channel6,DISABLE);			DMA_SetCurrDataCounter(DMA1_Channel6,1024);			DMA_Cmd(DMA1_Channel6,ENABLE);		}				I2C_DMACmd(I2C1,ENABLE);	#else		uint8_t *p 		= OLED_GRAM[0];		uint8_t *p_end 	= OLED_GRAM[0] + 1024;				/* SEND DATA */		for( ; p<p_end ; )		{			I2C1->DR = *p++;			while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));		}		I2C1->CR1 |= (1 << 9);	#endif#endif}/* * OLED refresh */void OLED_Refresh(void){	#ifdef USE_DMA		memcpy(TEMP_GRAM,OLED_GRAM,sizeof(TEMP_GRAM));	#endif	OLED_Fill();}/* * 图像显示 */void OLED_Refresh_Picture(const uint8_t *BMP){	#ifdef USE_DMA		memcpy(TEMP_GRAM,BMP,sizeof(TEMP_GRAM));	#else		memcpy(OLED_GRAM,BMP,sizeof(OLED_GRAM));	#endif	OLED_Fill();}/* * clear GRAM */void OLED_Clear_GRAM(void){	memset(OLED_GRAM, 0, sizeof(OLED_GRAM));}/* * draw point * x:0~127 * y:0~63 */void OLED_DrawPoint(int x,int y){	if(x>=OLED_W || y>=OLED_H)		return;		OLED_GRAM[y/8][x] |= (1 << (y%8));}/* * clear point * x:0~127 * y:0~63 */void OLED_ClearPoint(int x,int y){	if(x>=OLED_W || y>=OLED_H)		return;		OLED_GRAM[y/8][x] &= ~(1 << (y%8));}/* * draw line */void OLED_DrawLine(int x1,int y1,int x2,int y2){	uint16_t us;	uint16_t usX_Current, usY_Current;		int lError_X = 0, lError_Y = 0, lDelta_X, lDelta_Y, lDistance; 	int lIncrease_X, lIncrease_Y; 			lDelta_X = x2 - x1;	lDelta_Y = y2 - y1; 		usX_Current = x1; 	usY_Current = y1; 		if ( lDelta_X > 0 ) 		lIncrease_X = 1;	else if ( lDelta_X == 0 ) 		lIncrease_X = 0;	else 	{ 		lIncrease_X = -1;		lDelta_X = - lDelta_X;	} 	if ( lDelta_Y > 0 )		lIncrease_Y = 1; 	else if ( lDelta_Y == 0 )		lIncrease_Y = 0;	else 	{		lIncrease_Y = -1;		lDelta_Y = - lDelta_Y;	} 	if (  lDelta_X > lDelta_Y )		lDistance = lDelta_X;	else 		lDistance = lDelta_Y; 		for ( us = 0; us <= lDistance + 1; us ++ )	{  			OLED_DrawPoint(usX_Current,usY_Current);		lError_X += lDelta_X ; 		lError_Y += lDelta_Y ; 				if ( lError_X > lDistance ) 		{ 			lError_X -= lDistance; 			usX_Current += lIncrease_X; 		}  				if ( lError_Y > lDistance ) 		{ 			lError_Y -= lDistance; 			usY_Current += lIncrease_Y; 		} 			}  }/* * draw rectangle * x:0~127 * y:0~63 */void OLED_DrawRect(int left,int top,int width,int height){	OLED_DrawLine ( left, 		top, 		left+width, top);	OLED_DrawLine ( left, 		top+height, left+width, top+height);	OLED_DrawLine ( left, 		top, 		left, 		top+height);	OLED_DrawLine ( left+width, top,		left+width, top+height);	}#define OLED_MAX(x,y)	((x)>(y)? (x):(y))#define OLED_MIN(x,y)	((x)<(y)? (x):(y))/* * fast draw horizontal line */void OLED_DrawFastHLine(int x, int y, uint8_t w){	int a;	int end = x+w;		for ( a=OLED_MAX(0,x); a<OLED_MIN(end,128); a++ )	{		OLED_DrawPoint(a,y);	}}/* * fast draw perpendicular line */void OLED_DrawFastVLine(int x, int y, uint8_t h){	int a;	int end = y+h;		for ( a=OLED_MAX(0,y); a<OLED_MIN(end,64); a++ )	{		OLED_DrawPoint(x,a);	}}/* * Draw the rounded */void OLED_DrawCircleHelper(int x0, int y0, uint8_t r, uint8_t cornername){	int f = 1 - r;	int ddF_x = 1;	int ddF_y = -2 * r;	int x = 0;	int y = r;		while (x<y)	{		if (f >= 0)		{			y--;			ddF_y += 2;			f += ddF_y;		}		x++;		ddF_x += 2;		f += ddF_x;		if (cornername & 0x1)		{			OLED_DrawPoint(x0 - y, y0 - x);			OLED_DrawPoint(x0 - x, y0 - y);		}		if (cornername & 0x2)		{			OLED_DrawPoint(x0 + x, y0 - y);			OLED_DrawPoint(x0 + y, y0 - x);		}		if (cornername & 0x4)		{			OLED_DrawPoint(x0 + x, y0 + y);			OLED_DrawPoint(x0 + y, y0 + x);		}		if (cornername & 0x8)		{			OLED_DrawPoint(x0 - y, y0 + x);			OLED_DrawPoint(x0 - x, y0 + y);		}	}}/* * Draw a rounded rectangle */void OLED_DrawRoundRect(int x, int y, uint8_t w, uint8_t h, uint8_t r){	if((w < 2*r) || (h < 2*r))		return;		OLED_DrawFastHLine(x+r,   y,     w-2*r); // Top	OLED_DrawFastHLine(x+r,   y+h-1, w-2*r); // Bottom	OLED_DrawFastVLine(x,     y+r,   h-2*r); // Left	OLED_DrawFastVLine(x+w-1, y+r,   h-2*r); // Right	OLED_DrawCircleHelper(x+r,     y+r,     r, 1);	OLED_DrawCircleHelper(x+w-r-1, y+r,     r, 2);	OLED_DrawCircleHelper(x+w-r-1, y+h-r-1, r, 4);	OLED_DrawCircleHelper(x+r,     y+h-r-1, r, 8);}/* * Draw the ellipse */void OLED_DrawEllipse(int xCenter,int yCenter,int Rx,int Ry){	int Rx2=Rx*Rx;	int Ry2=Ry*Ry;	int twoRx2=2*Rx2;	int twoRy2=2*Ry2;	int p;	int x=0;	int y=Ry;	int px = 0;	int py = twoRx2*y;			OLED_DrawPoint(xCenter+x,yCenter+y);	OLED_DrawPoint(xCenter-x,yCenter+y);	OLED_DrawPoint(xCenter+x,yCenter-y);	OLED_DrawPoint(xCenter-x,yCenter-y);		//Region?1	p=(int)(Ry2-Rx2*Ry+0.25*Rx2);	while(px<py)	{		x++;		px+=twoRy2;		if(p<0)			p+=Ry2+px;		else		{			y--;			py-=twoRx2;			p+=Ry2+px-py;		}		OLED_DrawPoint(xCenter+x,yCenter+y);		OLED_DrawPoint(xCenter-x,yCenter+y);		OLED_DrawPoint(xCenter+x,yCenter-y);		OLED_DrawPoint(xCenter-x,yCenter-y);	}		//Region?2	p=(int)(Ry2*(x+0.5)*(x+0.5)+Rx2*(y-1)*(y-1)-Rx2*Ry2);	while(y>0)	{		y--;		py-=twoRx2;		if(p>0)			p+=Rx2-py;		else		{			x++;			px+=twoRy2;			p+=Rx2-py+px;		}		OLED_DrawPoint(xCenter+x,yCenter+y);		OLED_DrawPoint(xCenter-x,yCenter+y);		OLED_DrawPoint(xCenter+x,yCenter-y);		OLED_DrawPoint(xCenter-x,yCenter-y);	}}/* * draw circle */void OLED_DrawCircle(uint8_t x,uint8_t y,uint8_t r){	int a, b,num;    a = 0;    b = r;    while(2 * b * b >= r * r)          {        OLED_DrawPoint(x + a, y - b);        OLED_DrawPoint(x - a, y - b);        OLED_DrawPoint(x - a, y + b);        OLED_DrawPoint(x + a, y + b);         OLED_DrawPoint(x + b, y + a);        OLED_DrawPoint(x + b, y - a);        OLED_DrawPoint(x - b, y - a);        OLED_DrawPoint(x - b, y + a);                a++;        num = (a * a + b * b) - r*r;        if(num > 0)        {            b--;            a--;        }    }}/* * Draw a triangle */void OLED_DrawTriangle(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2){	OLED_DrawLine(x0, y0, x1, y1);	OLED_DrawLine(x1, y1, x2, y2);	OLED_DrawLine(x2, y2, x0, y0);}/*  * 字符显示 - API */void oled_show_char(uint16_t x, uint16_t y, uint8_t _char, uint8_t size){	uint8_t i, temp, bit;	uint16_t init_y = y;	uint8_t Byte_Num = (size/8 + ((size%8) ? 1 : 0)) * (size/2); /* 得到一个字符对应点阵集所占的字节数 */			_char = _char - ' '; /* 得到偏移后的值(ASCII字库是从空格开始取模,所以-' '就是对应字符的字库) */		for(i=0; i<Byte_Num; i++)	{   		if(size == 12)			temp = asc2_1206[_char][i]; /* 调用12*6字体 */		else if(size == 16)			temp = asc2_1608[_char][i]; /* 调用16*8字体 */		else if(size == 24)			temp = asc2_2412[_char][i]; /* 调用24*12字体 */		else return;				/* 单字节开始画点 */		for(bit=0; bit<8; bit++)		{			    			if(temp & 0x80) /* 取每个字节的每一位 */				OLED_DrawPoint(x, y); /* 字体色 */			else				OLED_ClearPoint(x, y); /* 背景色 */			temp <<= 1;			y++; /* 换行 */						if(x > 128) /* x超区域 */				return;			if(y > 64) /* y超区域 */				return;						if(y >= (init_y + size)) /* 换列 */			{				y = init_y;				x++;				break;			}		}	}}/*  * 显示字符串 - API */void oled_show_str(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t size, uint8_t *string){         	uint16_t init_x = x;	width  = x + width; /* 得到显示范围 */	height = height + y;	width  = (width > OLED_W) ? OLED_W : width;	height = (height> OLED_H) ? OLED_H : height;	while((*string <= '~') && ( *string >= ' '))	{		if(x >= width) /* 达到x轴显示范围自动换行 */		{			x = init_x;			y = y + size;		}		if(y >= height) /* 达到y轴显示范围结束 */		{			break;		}		oled_show_char(x, y, *string, size);						x += size/2; /* x轴增加y轴的一半 */			string++;	}  }/* * 数字显示 - API */void oled_show_num(uint16_t x, uint16_t y, uint8_t size, float num, uint8_t res){    float num_temp = num; /* 保存要显示的数字 */    float xnum;	uint32_t znum,znum_temp;    uint8_t znum_size = 0; /* 整数部分位数 */    uint8_t buf_size = 0; /* 缓存大小 */    signed char i;	    num = (num >= 0) ? num : -num;	res = (res > 3) ? 3 : res; /* 最多保留3位小数,浮点计算不精确 *//********************分离*******************/	znum = (uint32_t)num; /* 获取整数部分 */	xnum = num - (float)znum;	znum_temp = znum;/********************整数*******************/    while(znum > 0)    {        znum_size++;        znum /= 10;    }    buf_size = (znum_size == 0) ? (1 + 1 + 1 + res) : (1 + znum_size + 1 + res);    	uint8_t buf[buf_size]; /* 开缓存 */    memset(buf, 0, sizeof(buf));        if(num != num_temp)        buf[0] = '-';    else        buf[0] = '+';    for(i=znum_size; i>0; i--)    {        buf[i] = znum_temp%10 + 48;        znum_temp /= 10;    }    /* znum = 0 */    if(znum_size == 0)    {        znum_size = 1;        buf[znum_size] = '0';    }/********************小数*******************/	if(res != 0)	{        buf[znum_size + 1] = '.';        for(i=0; i<res; i++)        {            xnum *= 10.0f;            buf[znum_size + 2 + i] = (uint32_t)xnum + 48;            xnum -= (uint32_t)xnum;        }	}/*******************************************/	oled_show_str(x, y, sizeof(buf)*(size/2),size,size,buf); /*显示*/}/*************************************************待整理*******************************************//*************************************************待整理*******************************************//*************************************************待整理*******************************************/#include "bmp.h"#include "stdlib.h"#include "math.h"extern const unsigned char BMP1[];/* 图形库 */void oled_test(void){	int i,j,k;		OLED_Clear_GRAM();	//画线	for(i=0;i<40;i++)	{		OLED_DrawLine(0,0,i*10,63);		OLED_Refresh();		delay_ms(100);	}	for(i=0;i<40;i++)	{		OLED_DrawLine(127,0,127-i*10,63);		OLED_Refresh();		delay_ms(100);	}	delay_ms(1000);	//矩形	OLED_Clear_GRAM();	for(j=0;j<2;j++)	{		for(i=0;i<31;i+=2)		{			OLED_DrawRect((i+j)*2,(i+j),127-(i+j)*4,63-2*(i+j));			OLED_Refresh();			delay_ms(100);		}	}	delay_ms(1000);	//圆角矩形	OLED_Clear_GRAM();	for(i=0;i<31;i+=2)	{		OLED_DrawRoundRect((i)*2,i,128-i*4,64-2*i,10);		OLED_Refresh();		delay_ms(100);	}	delay_ms(1000);	//椭圆	OLED_Clear_GRAM();	OLED_DrawEllipse(63,31,63,31);	OLED_Refresh();	delay_ms(1000);	OLED_Clear_GRAM();	OLED_DrawEllipse(63,31,16,31);	OLED_Refresh();	delay_ms(1000);	OLED_Clear_GRAM();	//圆	OLED_DrawCircle(63,31,30);	OLED_Refresh();	delay_ms(1000);	OLED_Clear_GRAM();	//三角形	OLED_DrawTriangle(5,10,100,30,60,50);	OLED_Refresh();	delay_ms(1000);	OLED_Clear_GRAM();	//图像	OLED_Refresh_Picture(BMP1);	delay_ms(1000);	//圆弧	OLED_Clear_GRAM();	k = getsystick_us();	for(i=0;i<360;i++)	{		OLED_DrawArc(63,31,30,0,i);		OLED_Refresh();		OLED_Clear_GRAM();		delay_ms(1);	}	k = getsystick_us()-k;	oled_show_num(0,0,16,k,0);	OLED_Refresh();	delay_ms(2000);	//动画	OLED_ShowStars();		OLED_ShowWatch();	OLED_ShowTest(); 	delay_ms(1000);}static int cursor_x=0;static int cursor_y=0;#define SIZE 16void my_putchar(const char c){	if (c == '\n')	{		cursor_y += SIZE;		cursor_x  = 0;	}	else if (c == '\r')	{			}	else	{		oled_show_char(cursor_x, cursor_y, c, SIZE);		cursor_x += SIZE/2;					if (cursor_x > (127 - SIZE/2))		{			my_putchar('\n');		}	}    } void my_putstr(const char *str){	while(*str)	{		my_putchar(*str++);	}}static uint64_t print_pow(int x,int y){      uint64_t sum = 1;	      while(y--)      {           sum *= x;      }      return sum;}#include "stdarg.h"int my_printf(const char *str,...){	va_list ap;	int val,r_val;	char count,ch;	char *s = NULL;	int res = 0;	va_start(ap,str);	while('\0' != *str)	{ 		switch(*str)		{			case '%':				str++;				switch(*str)				{					case 'd':						val = va_arg(ap, int); 						r_val = val; 						count = 0; 						while(r_val)						{ 							count++;							r_val /= 10;						}						res += count; 						r_val = val; 						while(count)						{ 							ch = r_val / print_pow(10,count - 1);							r_val %= print_pow(10,count - 1);							my_putchar(ch + '0'); 							count--;						}						break;					case 'x': 						val = va_arg(ap, int); 						r_val = val; 						count = 0;						while(r_val) 						{ 							count++;							r_val /= 16; 						} 						res += count;						r_val = val; 						while(count) 						{ 							ch = r_val / print_pow(16, count - 1); 							r_val %= print_pow(16, count - 1);							if(ch <= 9)								my_putchar(ch + '0');							else 								my_putchar(ch - 10 + 'a'); 							count--;						}						break;					case 's':						s = va_arg(ap, char *); 							my_putstr(s); 						res += strlen(s);						break;					case 'c':						my_putchar( (char)va_arg(ap, int ));						res += 1;						break;					default:;				}				break;			case '\n':				my_putchar('\n'); 				res += 1;				break;			case '\r':				my_putchar('\r'); 				res += 1;				break;			default:				my_putchar(*str);				res += 1;		}		str++;	}	if(cursor_y+8>=63)		cursor_y=0;		va_end(ap);	    return res;}void wave(uint8_t *buf, int val){	uint8_t value = val;	OLED_Clear_GRAM();		for(int i=0; i<OLED_W-1; i++)	{		buf[i] = buf[i+1];		OLED_DrawPoint(i,buf[i]);	}		buf[OLED_W-1] = value;	OLED_DrawPoint(OLED_W-1,buf[127]);}#include "stdio.h"int fputc(int ch, FILE *f){     	static uint8_t x=0,y=16;	    if(ch == '\n') //换行     { 		x = 0;		y = 16;        return ch;     }     printc(x,y,ch,16);	OLED_Refresh();	y = 0;	x += 8;	    return ch; }void printc(uint16_t x, uint16_t y, uint8_t ch,uint8_t size){	static uint32_t now=0,next=0;		now = next;	next += y;		OLED_WR_CMD(0xD3);	OLED_WR_CMD(next%64);		#ifdef GRAM_MODE		oled_show_char(x,now%64,ch,size);		OLED_Refresh();	#else		oled_show_char(x,(now%64)/8,ch,size);	#endif	}//需改进typedef struct COORDINATE {	int x;	int y;}TypeXY;static int  _pointx=0;static int 	_pointy=0;static TypeXY GetXY(void){		TypeXY m;	m.x=_pointx;	m.y=_pointy;	return m;}typedef struct ROATE{	TypeXY center;	float angle;	int direct;}TypeRoate;static TypeRoate _RoateValue={{0,0},0,1};static void SetRotateCenter(int x0,int y0){	_RoateValue.center.x=x0;	_RoateValue.center.y=y0;}static void SetAnggleDir(int direction){	_RoateValue.direct=direction;}#define RADIAN(angle)  ((angle==0)?0:(3.14159*angle/180))static void SetAngle(float angle){	_RoateValue.angle=RADIAN(angle);}static float mySqrt(float x){	float a = x;	unsigned int i = *(unsigned int *)&x;	i = (i + 0x3f76cf62) >> 1;	x = *(float *)&i;	x = (x + a / x) * 0.5;	return x;}//需要优化atant2 cos sin算法static void Rotate(int x0,int y0,int*x,int*y,double angle,int direction){	//double r=sqrt((*y-y0)*(*y-y0)+(*x-x0)*(*x-x0));	int temp=(*y-y0)*(*y-y0)+(*x-x0)*(*x-x0);	double r=mySqrt(temp);	double a0=atan2(*x-x0,*y-y0);	if(direction)	{		*x=x0+r*cos(a0+angle);		*y=y0+r*sin(a0+angle);	}	else	{		*x=x0+r*cos(a0-angle);		*y=y0+r*sin(a0-angle);		}}static TypeXY GetRotateXY(int x,int y){	TypeXY temp;	int m=x,n=y;//	if(_RoateValue.angle!=0)		Rotate(_RoateValue.center.x,_RoateValue.center.y,&m,&n, _RoateValue.angle ,_RoateValue.direct);	temp.x=m;	temp.y=n;	return temp;}static void MoveTo(int x,int y){	_pointx=x;	_pointy=y;}static void LineTo(int x,int y){	OLED_DrawLine(_pointx,_pointy,x,y);	_pointx=x;	_pointy=y;}//圆弧void OLED_DrawArc(int x,int y,unsigned char r,int angle_start,int angle_end){	float i=0;	TypeXY m,temp;	temp=GetXY();	SetRotateCenter(x,y);	SetAnggleDir(0);	if(angle_end>360)		angle_end=360;	SetAngle(0);	m=GetRotateXY(x,y+r);	MoveTo(m.x,m.y);	for(i=angle_start;i<angle_end;i+=5)	{		SetAngle(i);		m=GetRotateXY(x,y+r);		LineTo(m.x,m.y);		//SetPointBuffer(m.x,m.y,GetDrawColor());	}	LineTo(x+r,y);	MoveTo(temp.x,temp.y);}u8 FrameRateUpdateScreen(int value){	static uint32_t temp;		if(systick_cnt_ms - temp > 1000/value)	{		OLED_Refresh();		OLED_Clear_GRAM();				temp = systick_cnt_ms;		return 1;	}	return 0;}//星空动画void OLED_ShowStars(void){	int i;	int fps=240;	int count=0;		typedef struct START	{		short x;		short y;		short speed;		unsigned char speedcount;		unsigned char isexist;	}Star;		Star star[128]={0};		srand(2);	for(i=0;i<128;i++)	{		if(star[i].isexist==0)		{			star[i].x = rand()%127;			star[i].y = rand()%64;			star[i].speedcount=0;			star[i].speed=rand()%8+1;			star[i].isexist=1;		}	}		while(1)	{		if(FrameRateUpdateScreen(fps)==1)		{			count++;			if(count>=fps*5)   //10秒钟				return;		}					for(i=0; i<128; i++)		{			if(star[i].isexist==0)			{								star[i].x=0;				star[i].y=rand()%64;				star[i].speed=rand()%6+1;				star[i].speedcount=0;				star[i].isexist=1;			}			else			{				star[i].speedcount++;								if(star[i].x>=124)				{					star[i].isexist=0;				}				OLED_DrawLine(star[i].x,star[i].y,star[i].x,star[i].y);								if(star[i].speedcount==star[i].speed)				{					star[i].speedcount=0;					star[i].x+=1;				}				OLED_DrawLine(star[i].x,star[i].y,star[i].x+(6/star[i].speed)-1,star[i].y);			}					}	}}void SetRotateValue(int x,int y,float angle,int direct){	SetRotateCenter(x,y);	SetAnggleDir(direct);	SetAngle(angle);}//钟,角度还没有同步还需要调整，void RoundClock(int hours ,int minute ,int sec){	//FrameRateUpdateScreen(60);	unsigned char i=0;	TypeXY hourspoint,minutepoint,secpoint,tmp1,tmp2;	//时针	SetRotateValue(63,31,hours*30+(minute*30)/60,1);	hourspoint=GetRotateXY(63-14,31);	OLED_DrawLine(63,31,hourspoint.x,hourspoint.y);	//分针	SetRotateValue(63,31,minute*6+(sec*6)/60,1);	minutepoint=GetRotateXY(63-21,31);	OLED_DrawLine(63,31,minutepoint.x,minutepoint.y);		//秒针	SetRotateValue(63,31,sec*6,1);	secpoint=GetRotateXY(63-28,31);	OLED_DrawLine(63,31,secpoint.x,secpoint.y);	//表盘	for(i=0;i<12;i++)	{		SetRotateValue(63,31,i*30,1);		tmp1=GetRotateXY(63-29,31);		tmp2=GetRotateXY(63-24,31);		OLED_DrawLine(tmp1.x,tmp1.y,tmp2.x,tmp2.y);	}	OLED_DrawCircle(63,31,2);	OLED_DrawCircle(63,31,30);	OLED_Refresh();	OLED_Clear_GRAM();}void OLED_ShowWatch(void){	int i,j,z;	int count=0;	for(i=0;i<12;i++)	{		for(j=0;j<60;j++)		{			for(z=0;z<60;z++)			{				RoundClock(i,j,z);				count++;				if(count>=800)				{					return ;				}			}		}	}}/****************************立方体*****************************/#define DD	18	/* 边长 *//* 立方体各顶点初始坐标 */float cubeinit[8][3] = {	{-DD,-DD,-DD},							{-DD, DD,-DD},							{ DD, DD,-DD},							{ DD,-DD,-DD},							{-DD,-DD, DD},							{-DD, DD, DD},							{ DD, DD, DD},							{ DD,-DD, DD}};/* 立方体各顶点实时坐标 */float cubenew[8][3];	/* 各点连线顺序 */int lineid[24] = {1,2,2,3,3,4,4,1,/*底面*/   5,6,6,7,7,8,8,5,/*顶面*/   8,4,  7,3,  6,2,  5,1/*侧棱*/};	/* 计算旋转后的向量 */float* matconv(float pointold[3], float pointnew[3], float spin_matrix[3][3]){	float res[3];		for(int i=0; i<3; i++)	{		res[i]  = 	spin_matrix[i][0]*pointold[0] + 					spin_matrix[i][1]*pointold[1] + 					spin_matrix[i][2]*pointold[2];	}		for(int i=0;i<3;i++)	{		pointnew[i]=res[i]; 	}	return pointnew;}void rotate(float Cubeinit[][3],float Cubenew[][3],float x,float y,float z){	/* 旋转矩阵 */	float rz[3][3]={{cos(z), -sin(z),   0   },					{sin(z),  cos(z),   0   },					{  0   ,    0   ,   1   }};		float ry[3][3]={{  1,       0  ,    0   },					{  0,    cos(y), -sin(y)},					{  0,    sin(y),  cos(y)}};		float rx[3][3]={{ cos(x),   0,    sin(x)},					{  0    ,   1,       0  },					{-sin(x),   0,    cos(x)}};		/* 旋转向量 */	for(int i=0; i<8; i++)		matconv(matconv(matconv(Cubeinit[i],Cubenew[i],rz),Cubenew[i],ry),Cubenew[i],rx);}float x=0,y=0,z=2;void loop(){  	y = 0.3;	x += 0.2;	z = 0.3;	/* 坐标偏转更新 */	rotate(cubeinit,cubenew,x,y,z);		/* 绘制立方体 */	for(int i=0;i<24;i+=2)		OLED_DrawLine(64+cubenew[lineid[i]-1][0],32+cubenew[lineid[i]-1][1],64+cubenew[lineid[i+1]-1][0],32+cubenew[lineid[i+1]-1][1]);} /////////////////////////////void OLED_ShowTest(void){	int x0=63,y0=31;	unsigned char i =0,j;	int n=1,r=31,v=1,count=0;	int x[30],y[30];		while(1)	{		OLED_Clear_GRAM();//		for(i=0;i<n;i++)//		{//			x[i]=r*cos(2*3.1415926*i/n)+x0;//			y[i]=r*sin(2*3.1415926*i/n)+y0;//		}//		for(i=0;i<=n-2;i++)//		{//			for(j=i+1;j<=n-1;j++)//				OLED_DrawLine(x[i],y[i],x[j],y[j]);//		}//		n+=v;//		if(n==20||n==0)//			v=-v;//		delay_ms(100);				loop();				OLED_Refresh();		if(++count==90)		{			count=0;			return ;		}	}}