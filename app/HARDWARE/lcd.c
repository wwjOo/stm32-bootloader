#include "lcd.h"#include "lcdfont.h"#include "delay.h"/* DMA work finish flag */uint8_t DMA_Finish = 1;#define RESERVED	0/* * spi / gpio / DMA init */void spi_init(void){	/* GPIO SPI1 */	GPIO_InitTypeDef GPIO_InitStruct;		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	/* PA5-SCK PA7-MOSI */	GPIO_InitStruct.GPIO_Pin 	= GPIO_Pin_5|GPIO_Pin_7;	GPIO_InitStruct.GPIO_Speed 	= GPIO_Speed_50MHz;	GPIO_InitStruct.GPIO_Mode 	= GPIO_Mode_AF_PP;	GPIO_Init(GPIOA, &GPIO_InitStruct);		/* GPIO OTHERS */	GPIO_InitStruct.GPIO_Pin 	= GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4;	  	GPIO_InitStruct.GPIO_Mode 	= GPIO_Mode_Out_PP; 	GPIO_Init(GPIOA, &GPIO_InitStruct);		/* SPI1 */	SPI_InitTypeDef SPI_InitStruct;	/* 72M */	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);		SPI_InitStruct.SPI_BaudRatePrescaler= SPI_BaudRatePrescaler_2;	SPI_InitStruct.SPI_CPHA 			= SPI_CPHA_2Edge;	SPI_InitStruct.SPI_CPOL 			= SPI_CPOL_High; 			/* SDA is sampled at the rising edge of SCL */	SPI_InitStruct.SPI_CRCPolynomial	= 7; 						/* default */	SPI_InitStruct.SPI_DataSize 		= SPI_DataSize_8b;			/* default 8bits */	SPI_InitStruct.SPI_Direction 		= SPI_Direction_1Line_Tx;	SPI_InitStruct.SPI_FirstBit 		= SPI_FirstBit_MSB; 		/* The MSB is transmitted first in LCD */	SPI_InitStruct.SPI_Mode 			= SPI_Mode_Master;	SPI_InitStruct.SPI_NSS 				= SPI_NSS_Soft;	SPI_Init(SPI1, &SPI_InitStruct);		SPI_Cmd(SPI1, ENABLE);		/* DMA */	/* SPI1_TX - DMA1_CH3 */	DMA_InitTypeDef  DMA_InitStruct;	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);		DMA_InitStruct.DMA_BufferSize 			= RESERVED;	DMA_InitStruct.DMA_DIR 					= DMA_DIR_PeripheralDST;	DMA_InitStruct.DMA_M2M 					= DMA_M2M_Disable;	DMA_InitStruct.DMA_MemoryBaseAddr 		= RESERVED;	DMA_InitStruct.DMA_MemoryDataSize 		= RESERVED;	DMA_InitStruct.DMA_MemoryInc			= RESERVED;	DMA_InitStruct.DMA_Mode 				= DMA_Mode_Normal;	DMA_InitStruct.DMA_PeripheralBaseAddr 	= (uint32_t)&SPI1->DR;	DMA_InitStruct.DMA_PeripheralDataSize 	= RESERVED;	DMA_InitStruct.DMA_PeripheralInc		= DMA_PeripheralInc_Disable;	DMA_InitStruct.DMA_Priority 			= DMA_Priority_VeryHigh;	DMA_Init(DMA1_Channel3, &DMA_InitStruct);		DMA_ITConfig(DMA1_Channel3,DMA_IT_TC,ENABLE);		NVIC_InitTypeDef NVIC_InitStruct;	NVIC_InitStruct.NVIC_IRQChannel		=DMA1_Channel3_IRQn;	NVIC_InitStruct.NVIC_IRQChannelCmd	=ENABLE;	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority	= 2;	NVIC_InitStruct.NVIC_IRQChannelSubPriority			= 2;	NVIC_Init(&NVIC_InitStruct);		DMA_Cmd(DMA1_Channel3, ENABLE);}/* * write a _u8 data or cmd */void LCD_u8WR(uint8_t type, uint8_t value){		if(type == CMD)		CMD_READY;	else		DAT_READY;		SEND_START;	SPI_I2S_SendData(SPI1,value);	while(!SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE));	SEND_END;}/* * write a _u16 data */void LCD_u16WR(uint16_t data){	DAT_READY;		SEND_START;	SPI_I2S_SendData(SPI1,data>>8);	while(!SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE));	SPI_I2S_SendData(SPI1,data);	while(!SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE));	SEND_END;}/* * Display Inversion */void lcd_inversion_set(uint8_t state){	switch(state)	{		case 0:			LCD_u8WR(CMD,0x20);			break;		case 1:			/* Display Inversion On - This command is used to enter into display inversion mode */			LCD_u8WR(CMD,0x21);			break;		default:			break;	}}/* * Display ctrl */void lcd_display_ctrl(uint8_t state){	switch(state)	{		case 0:			LCD_u8WR(CMD,0x28);			break;		case 1:			LCD_u8WR(CMD,0x29);			break;		default:			break;	}}/* * set addr range */void lcd_addr_range(uint8_t xstart,uint8_t ystart,uint8_t xend,uint8_t yend){	xend = xend > (SCREEN_W-1) ? (SCREEN_W-1) : xend;	yend = yend > (SCREEN_H-1) ? (SCREEN_H-1) : yend;		/* portrait screen */	if(USE_HORIZONTAL >= 0 && USE_HORIZONTAL <= 3)	{		/* column addr range - 80 */		LCD_u8WR(CMD,0x2A);		LCD_u16WR(xstart+24);		LCD_u16WR(xend+24);		/* row addr range - 160 */		LCD_u8WR(CMD,0x2B);		LCD_u16WR(ystart);		LCD_u16WR(yend);	}	/* landscape screen */	else	{		/* column addr range - 80 */		LCD_u8WR(CMD,0x2A);		LCD_u16WR(xstart);		LCD_u16WR(xend);		/* row addr range - 160 */		LCD_u8WR(CMD,0x2B);		LCD_u16WR(ystart+24);		LCD_u16WR(yend+24);	}		/* save */	LCD_u8WR(CMD,0x2C);}/* * lcd init */void lcd_init(void){	uint16_t init_fill = INIT_FILL;		spi_init();		/* H/W reset */	LCD_RES_L();	delay_ms(150);	LCD_RES_H();	delay_ms(150);		/**************configuration**************/	/**************configuration**************/	/**************configuration**************/	/* S/W reset - it will be necessary to wait 120msec before sending next command */	LCD_u8WR(CMD,0x01); 	delay_ms(150);	/* sleep out - it will be necessary to wait 120msec before sending next command */	LCD_u8WR(CMD,0x11); 	delay_ms(150);		/* Set the frame frequency of the full colors normal mode */	LCD_u8WR(CMD,0xB1);	LCD_u8WR(DATA,0x05);	LCD_u8WR(DATA,0x3C);	LCD_u8WR(DATA,0x3C);		/* Set the frame frequency of the Idle mode */	LCD_u8WR(CMD,0xB2);	LCD_u8WR(DATA,0x05);	LCD_u8WR(DATA,0x3C);	LCD_u8WR(DATA,0x3C);		/* Set the frame frequency of the Partial mode/ full colors */	LCD_u8WR(CMD,0xB3);	LCD_u8WR(DATA,0x05);	LCD_u8WR(DATA,0x3C);	LCD_u8WR(DATA,0x3C);	LCD_u8WR(DATA,0x05);   	LCD_u8WR(DATA,0x3C);   	LCD_u8WR(DATA,0x3C);		/* Power Control 1 */	LCD_u8WR(CMD,0xC0);	LCD_u8WR(DATA,0xAB);	LCD_u8WR(DATA,0x0B);	LCD_u8WR(DATA,0x04);	/* Power Control 2 */	LCD_u8WR(CMD,0xC1);	LCD_u8WR(DATA,0xC5);	/* Power Control 3 */	LCD_u8WR(CMD,0xC2);	LCD_u8WR(DATA,0x0D);   	LCD_u8WR(DATA,0x00);   	/* Power Control 4 */	LCD_u8WR(CMD,0xC3);	LCD_u8WR(DATA,0x8D);   	LCD_u8WR(DATA,0x6A);	/* Power Control 5 */	LCD_u8WR(CMD,0xC4);	LCD_u8WR(DATA,0x8D);   	LCD_u8WR(DATA,0xEE);		/* VCOM voltage setting */	LCD_u8WR(CMD,0xC5);	LCD_u8WR(DATA,0x0F);   		/* Gamma (‘+’polarity) Correction Characteristics Setting */	LCD_u8WR(CMD,0xE0); 	//positive gamma	LCD_u8WR(DATA,0x07);   	LCD_u8WR(DATA,0x0E);   	LCD_u8WR(DATA,0x08);   	LCD_u8WR(DATA,0x07);   	LCD_u8WR(DATA,0x10);   	LCD_u8WR(DATA,0x07);   	LCD_u8WR(DATA,0x02);   	LCD_u8WR(DATA,0x07);   	LCD_u8WR(DATA,0x09);   	LCD_u8WR(DATA,0x0F);   	LCD_u8WR(DATA,0x25);   	LCD_u8WR(DATA,0x36);   	LCD_u8WR(DATA,0x00);   	LCD_u8WR(DATA,0x08);   	LCD_u8WR(DATA,0x04);   	LCD_u8WR(DATA,0x10);		/* Gamma ‘-’polarity Correction Characteristics Setting */	LCD_u8WR(CMD,0xE1);	//negative gamma	LCD_u8WR(DATA,0x0A);   	LCD_u8WR(DATA,0x0D);   	LCD_u8WR(DATA,0x08);   	LCD_u8WR(DATA,0x07);   	LCD_u8WR(DATA,0x0F);   	LCD_u8WR(DATA,0x07);   	LCD_u8WR(DATA,0x02);   	LCD_u8WR(DATA,0x07);   	LCD_u8WR(DATA,0x09);   	LCD_u8WR(DATA,0x0F);   	LCD_u8WR(DATA,0x25);   	LCD_u8WR(DATA,0x35);   	LCD_u8WR(DATA,0x00);   	LCD_u8WR(DATA,0x09);   	LCD_u8WR(DATA,0x04);   	LCD_u8WR(DATA,0x10);		 	/*  Gate Pump Clock Frequency Variable - Automatic adjust gate pumping clock for saving power consumption */	LCD_u8WR(CMD,0xFC);	LCD_u8WR(DATA,0x80);			/* Interface Pixel Format - This command is used to define the format of RGB picture data, which is to be transferred via the MCU interface */	LCD_u8WR(CMD,0x3A);     	LCD_u8WR(DATA,0x05); // 16-bit/pixel		/* Memory Data Access Control - This command defines read/ write scanning direction of frame memory */	LCD_u8WR(CMD,0x36);	if(USE_HORIZONTAL == 0)		LCD_u8WR(DATA,0x00); /* portrait screen */	if(USE_HORIZONTAL == 1)		LCD_u8WR(DATA,0x40); /* U - D invert */	if(USE_HORIZONTAL == 2)		LCD_u8WR(DATA,0x80); /* L - R invert */	if(USE_HORIZONTAL == 3)		LCD_u8WR(DATA,0xC0); /* U-D & L-R invert */		if(USE_HORIZONTAL == 4)		LCD_u8WR(DATA,0x20); /* portrait screen */	if(USE_HORIZONTAL == 5)		LCD_u8WR(DATA,0x60); /* U - D invert */	if(USE_HORIZONTAL == 6)		LCD_u8WR(DATA,0xA0); /* L - R invert */	if(USE_HORIZONTAL == 7)		LCD_u8WR(DATA,0xE0); /* U-D & L-R invert */	/**************configuration**************/	/**************configuration**************/	/**************configuration**************/		/* backlight on */	LCD_BLK_ON();		/* display on */	lcd_display_ctrl(1);		/* init fill */	lcd_DMAFill(0, 0, SCREEN_W, SCREEN_H, &init_fill,DMA_MemoryInc_Disable);	delay_ms(50);}/* * set SPI bit */void SPI_Set_DataBit(uint8_t num){	SPI1->CR1 &= ~(1 << 6);	/* disable spi */		if( num == 8 )		SPI1->CR1 &= ~(1 << 11); /* 8 bits */	else if( num == 16 )		SPI1->CR1 |=  (1 << 11); /* 16 bits */		SPI1->CR1 |=  (1 << 6);	/* enable spi */}/* * DMA TC INTERRUPT */void DMA1_Channel3_IRQHandler(void){	if(DMA_GetFlagStatus(DMA1_FLAG_TC3) != 0)	{		DMA_ClearFlag(DMA1_FLAG_TC3);				SPI_I2S_DMACmd(SPI1,SPI_I2S_DMAReq_Tx,DISABLE);		DMA_Finish = 1;				/* data send end */		SEND_END;				/* set SPI data length to 8 bits */		SPI_Set_DataBit(8);	}}/* * DMA work prepare */uint8_t DMA_Work_Prepare(uint32_t DMA_MemoryBaseAddr, uint8_t datalen, uint32_t DMA_BufferSize, uint32_t DMA_MemoryInc){	if(!IS_DMA_MEMORY_INC_STATE(DMA_MemoryInc))		return 0;		/* Set SPI data length */	SPI_Set_DataBit(datalen);		/* Reconfigure DMA */	DMA_Cmd(DMA1_Channel3,DISABLE);		DMA1_Channel3->CMAR = DMA_MemoryBaseAddr; 				/* memory addr */	DMA1_Channel3->CNDTR = DMA_BufferSize;					/* data counter */		DMA1_Channel3->CCR &= ~DMA_MemoryInc_Enable;			/* MemoryInc Disable */	if( DMA_MemoryInc == DMA_MemoryInc_Enable )				/* MemoryInc Enable */		DMA1_Channel3->CCR |= DMA_MemoryInc_Enable;					DMA1_Channel3->CCR &= ~(0x0F << 8);						/* 8 bits transfer */	if( datalen == 16 )										/* 16 bits transfer */		DMA1_Channel3->CCR |=  (1 << 8)|(1 << 10);		DMA_Cmd(DMA1_Channel3,ENABLE);		return 1;}/*  * DMA color fill (it will cost about [5.7ms] when there are [80*160] halfwords need to be transfered) */void lcd_DMAFill(uint8_t x0, uint8_t y0, uint8_t w, uint8_t h, uint16_t *fill_color, uint32_t DMA_MemoryInc){	if( DMA_Finish == 1 )	{		x0 = (x0 > SCREEN_W-1) ? (SCREEN_W-1) : x0;		y0 = (y0 > SCREEN_H-1) ? (SCREEN_H-1) : y0;				w = (x0+w > SCREEN_W) ? (SCREEN_W - x0) : w;		h = (y0+h > SCREEN_H) ? (SCREEN_H - y0) : h;				/* set addr range */		lcd_addr_range(x0,y0,x0+w-1,y0+h-1);				/* data write ready */		DAT_READY;				/* prepare */		if(!DMA_Work_Prepare((uint32_t)fill_color, 16, w*h, DMA_MemoryInc))			return;				/* start */		SEND_START;		SPI_I2S_DMACmd(SPI1,SPI_I2S_DMAReq_Tx,ENABLE);		DMA_Finish = 0;	}}/*  * DMA fill picture */void lcd_DMAFill_Picture(uint8_t x0, uint8_t y0, uint8_t w, uint8_t h, const uint8_t *pdata){	if( DMA_Finish == 1 )	{		x0 = (x0 > SCREEN_W-1) ? (SCREEN_W-1) : x0;		y0 = (y0 > SCREEN_H-1) ? (SCREEN_H-1) : y0;				w = (x0+w > SCREEN_W) ? (SCREEN_W - x0) : w;		h = (y0+h > SCREEN_H) ? (SCREEN_H - y0) : h;				/* set addr range */		lcd_addr_range(x0,y0,x0+w-1,y0+h-1);				/* data write ready */		DAT_READY;				/* prepare */		if(!DMA_Work_Prepare((uint32_t)pdata, 8, w*h*2, DMA_MemoryInc_Enable))			return;				/* start */		SEND_START;		SPI_I2S_DMACmd(SPI1,SPI_I2S_DMAReq_Tx,ENABLE);		DMA_Finish = 0;	}}/* * common color fill (it will cost about [34.3ms] when there are [80*160] halfwords need to be filled) */void lcd_Fill(uint8_t x0, uint8_t y0, uint8_t w, uint8_t h, uint16_t fill_color){      	uint16_t i;		x0 = (x0 > SCREEN_W-1) ? (SCREEN_W-1) : x0;	y0 = (y0 > SCREEN_H-1) ? (SCREEN_H-1) : y0;		w = (x0+w > SCREEN_W) ? (SCREEN_W - x0) : w;	h = (y0+h > SCREEN_H) ? (SCREEN_H - y0) : h;		/* set addr range */	lcd_addr_range(x0,y0,x0+w-1,y0+h-1);	 	for(i=0; i<w*h; i++)	{						LCD_u16WR(fill_color);	}}/* * draw point (it will cost about [20us]) */void lcd_DrawPoint(int x,int y,uint16_t color){	if( x>SCREEN_W-1 || y>SCREEN_H-1 )		return;		lcd_addr_range(x,y,1,1);	LCD_u16WR(color);}/* * draw line */void lcd_DrawLine(int x1,int y1,int x2,int y2,uint16_t color){	uint16_t us;	uint16_t usX_Current, usY_Current;		int lError_X = 0, lError_Y = 0, lDelta_X, lDelta_Y, lDistance; 	int lIncrease_X, lIncrease_Y; 			lDelta_X = x2 - x1;	lDelta_Y = y2 - y1; 		usX_Current = x1; 	usY_Current = y1; 		if ( lDelta_X > 0 ) 		lIncrease_X = 1;	else if ( lDelta_X == 0 ) 		lIncrease_X = 0;	else 	{ 		lIncrease_X = -1;		lDelta_X = - lDelta_X;	} 	if ( lDelta_Y > 0 )		lIncrease_Y = 1; 	else if ( lDelta_Y == 0 )		lIncrease_Y = 0;	else 	{		lIncrease_Y = -1;		lDelta_Y = - lDelta_Y;	} 	if (  lDelta_X > lDelta_Y )		lDistance = lDelta_X;	else 		lDistance = lDelta_Y; 		for ( us = 0; us <= lDistance + 1; us ++ )	{  			lcd_DrawPoint(usX_Current,usY_Current,color);		lError_X += lDelta_X ; 		lError_Y += lDelta_Y ; 				if ( lError_X > lDistance ) 		{ 			lError_X -= lDistance; 			usX_Current += lIncrease_X; 		}  				if ( lError_Y > lDistance ) 		{ 			lError_Y -= lDistance; 			usY_Current += lIncrease_Y; 		} 			}  }/* * draw rectangle */void lcd_DrawRect(int left,int top,int width,int height, uint16_t color){	lcd_DrawLine ( left, 		top, 		left+width, top,		color);	lcd_DrawLine ( left, 		top+height, left+width, top+height,	color);	lcd_DrawLine ( left, 		top, 		left, 		top+height,	color);	lcd_DrawLine ( left+width, 	top,		left+width, top+height,	color);	}#define LCD_MAX(x,y)	((x)>(y)? (x):(y))#define LCD_MIN(x,y)	((x)<(y)? (x):(y))/* * fast draw horizontal line */void lcd_DrawFastHLine(int x, int y, int w, uint16_t color){	int a;	int end = x+w;		for ( a=LCD_MAX(0,x); a<LCD_MIN(end,SCREEN_W); a++ )	{		lcd_DrawPoint(a,y,color);	}}/* * fast draw perpendicular line */void lcd_DrawFastVLine(int x, int y, int h, uint16_t color){	int a;	int end = y+h;		for ( a=LCD_MAX(0,y); a<LCD_MIN(end,SCREEN_H); a++ )	{		lcd_DrawPoint(x,a,color);	}}/* * Draw the rounded */void lcd_DrawCircleHelper(int x0, int y0, int r, uint8_t cornername, uint16_t color){	int f = 1 - r;	int ddF_x = 1;	int ddF_y = -2 * r;	int x = 0;	int y = r;		while (x<y)	{		if (f >= 0)		{			y--;			ddF_y += 2;			f += ddF_y;		}		x++;		ddF_x += 2;		f += ddF_x;		if (cornername & 0x1)		{			lcd_DrawPoint(x0 - y, y0 - x, color);			lcd_DrawPoint(x0 - x, y0 - y, color);		}		if (cornername & 0x2)		{			lcd_DrawPoint(x0 + x, y0 - y, color);			lcd_DrawPoint(x0 + y, y0 - x, color);		}		if (cornername & 0x4)		{			lcd_DrawPoint(x0 + x, y0 + y, color);			lcd_DrawPoint(x0 + y, y0 + x, color);		}		if (cornername & 0x8)		{			lcd_DrawPoint(x0 - y, y0 + x, color);			lcd_DrawPoint(x0 - x, y0 + y, color);		}	}}/* * Draw a rounded rectangle */void lcd_DrawRoundRect(int x, int y, int w, int h, int r, uint16_t color){	if((w < 2*r) || (h < 2*r))		return;		lcd_DrawFastHLine(x+r,   y,     w-2*r, color); // Top	lcd_DrawFastHLine(x+r,   y+h-1, w-2*r, color); // Bottom	lcd_DrawFastVLine(x,     y+r,   h-2*r, color); // Left	lcd_DrawFastVLine(x+w-1, y+r,   h-2*r, color); // Right	lcd_DrawCircleHelper(x+r,     y+r,     r, 1, color);	lcd_DrawCircleHelper(x+w-r-1, y+r,     r, 2, color);	lcd_DrawCircleHelper(x+w-r-1, y+h-r-1, r, 4, color);	lcd_DrawCircleHelper(x+r,     y+h-r-1, r, 8, color);}/* * Draw the ellipse */void lcd_DrawEllipse(int xCenter,int yCenter,int Rx,int Ry, uint16_t color){	int Rx2=Rx*Rx;	int Ry2=Ry*Ry;	int twoRx2=2*Rx2;	int twoRy2=2*Ry2;	int p;	int x=0;	int y=Ry;	int px = 0;	int py = twoRx2*y;			lcd_DrawPoint(xCenter+x,yCenter+y,color);	lcd_DrawPoint(xCenter-x,yCenter+y,color);	lcd_DrawPoint(xCenter+x,yCenter-y,color);	lcd_DrawPoint(xCenter-x,yCenter-y,color);		//Region?1	p=(int)(Ry2-Rx2*Ry+0.25*Rx2);	while(px<py)	{		x++;		px+=twoRy2;		if(p<0)			p+=Ry2+px;		else		{			y--;			py-=twoRx2;			p+=Ry2+px-py;		}		lcd_DrawPoint(xCenter+x,yCenter+y,color);		lcd_DrawPoint(xCenter-x,yCenter+y,color);		lcd_DrawPoint(xCenter+x,yCenter-y,color);		lcd_DrawPoint(xCenter-x,yCenter-y,color);	}		//Region?2	p=(int)(Ry2*(x+0.5)*(x+0.5)+Rx2*(y-1)*(y-1)-Rx2*Ry2);	while(y>0)	{		y--;		py-=twoRx2;		if(p>0)			p+=Rx2-py;		else		{			x++;			px+=twoRy2;			p+=Rx2-py+px;		}		lcd_DrawPoint(xCenter+x,yCenter+y,color);		lcd_DrawPoint(xCenter-x,yCenter+y,color);		lcd_DrawPoint(xCenter+x,yCenter-y,color);		lcd_DrawPoint(xCenter-x,yCenter-y,color);	}}/* * draw circle */void lcd_DrawCircle(int x,int y,int r,uint16_t color){	int a, b,num;    a = 0;    b = r;    while(2 * b * b >= r * r)          {        lcd_DrawPoint(x + a, y - b,color);        lcd_DrawPoint(x - a, y - b,color);        lcd_DrawPoint(x - a, y + b,color);        lcd_DrawPoint(x + a, y + b,color);        lcd_DrawPoint(x + b, y + a,color);        lcd_DrawPoint(x + b, y - a,color);        lcd_DrawPoint(x - b, y - a,color);        lcd_DrawPoint(x - b, y + a,color);                a++;        num = (a * a + b * b) - r*r;        if(num > 0)        {            b--;            a--;        }    }}/* * Draw a triangle */void lcd_DrawTriangle(int x0, int y0, int x1, int y1, int x2, int y2, uint16_t color){	lcd_DrawLine(x0, y0, x1, y1, color);	lcd_DrawLine(x1, y1, x2, y2, color);	lcd_DrawLine(x2, y2, x0, y0, color);}/*  * 字符显示 - API */void lcd_show_char(uint16_t x, uint16_t y, uint8_t _char, uint8_t size, uint16_t color){	uint8_t i, temp, bit;	uint16_t init_y = y;	uint8_t Byte_Num = (size/8 + ((size%8) ? 1 : 0)) * (size/2); /* 得到一个字符对应点阵集所占的字节数 */			_char = _char - ' '; /* 得到偏移后的值(ASCII字库是从空格开始取模,所以-' '就是对应字符的字库) */		for(i=0; i<Byte_Num; i++)	{   		if(size == 12)			temp = lcd_asc2_1206[_char][i]; /* 调用12*6字体 */		else if(size == 16)			temp = lcd_asc2_1608[_char][i]; /* 调用16*8字体 */		else if(size == 24)			temp = lcd_asc2_2412[_char][i]; /* 调用24*12字体 */		else return;				/* 单字节开始画点 */		for(bit=0; bit<8; bit++)		{			    			if(temp & 0x80) /* 取每个字节的每一位 */				lcd_DrawPoint(x, y, color); /* 字体色 */			else				lcd_DrawPoint(x, y, INIT_FILL); /* 背景色 */			temp <<= 1;			y++; /* 换行 */						if(x > 128) /* x超区域 */				return;			if(y > 64) /* y超区域 */				return;						if(y >= (init_y + size)) /* 换列 */			{				y = init_y;				x++;				break;			}		}	}}/*  * 显示字符串 - API */void lcd_show_str(uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint8_t size, uint8_t *string, uint16_t color){         	uint16_t init_x = x;	width  = x + width; /* 得到显示范围 */	height = height + y;	width  = (width > 128) ? 128 : width;	height = (height> 64)  ? 64  : height;	while((*string <= '~') && ( *string >= ' '))	{		if(x >= width) /* 达到x轴显示范围自动换行 */		{			x = init_x;			y = y + size;		}		if(y >= height) /* 达到y轴显示范围结束 */		{			break;		}		lcd_show_char(x, y, *string, size, color);						x += size/2; /* x轴增加y轴的一半 */			string++;	}  }/* * 数字显示 - API */#include "string.h"void lcd_show_num(uint16_t x, uint16_t y, uint8_t size, float num, uint8_t res, uint16_t color){    float num_temp = num; /* 保存要显示的数字 */    float xnum;	uint32_t znum,znum_temp;    uint8_t znum_size = 0; /* 整数部分位数 */    uint8_t buf_size = 0; /* 缓存大小 */    signed char i;	    num = (num >= 0) ? num : -num;	res = (res > 3) ? 3 : res; /* 最多保留3位小数,浮点计算不精确 *//********************分离*******************/	znum = (uint32_t)num; /* 获取整数部分 */	xnum = num - (float)znum;	znum_temp = znum;/********************整数*******************/    while(znum > 0)    {        znum_size++;        znum /= 10;    }    buf_size = (znum_size == 0) ? (1 + 1 + 1 + res) : (1 + znum_size + 1 + res);    	uint8_t buf[buf_size]; /* 开缓存 */    memset(buf, 0, sizeof(buf));        if(num != num_temp)        buf[0] = '-';    else        buf[0] = '+';    for(i=znum_size; i>0; i--)    {        buf[i] = znum_temp%10 + 48;        znum_temp /= 10;    }    /* znum = 0 */    if(znum_size == 0)    {        znum_size = 1;        buf[znum_size] = '0';    }/********************小数*******************/	if(res != 0)	{        buf[znum_size + 1] = '.';        for(i=0; i<res; i++)        {            xnum *= 10.0f;            buf[znum_size + 2 + i] = (uint32_t)xnum + 48;            xnum -= (uint32_t)xnum;        }	}/*******************************************/	lcd_show_str(x, y, sizeof(buf)*(size/2),size,size,buf,color); /*显示*/}/************************************************************************//************************************************************************//************************************************************************///需改进typedef struct COORDINATE {	int x;	int y;}TypeXY;static int  _pointx=0;static int 	_pointy=0;TypeXY GetXY(void){		TypeXY m;	m.x=_pointx;	m.y=_pointy;	return m;}typedef struct ROATE{	TypeXY center;	float angle;	int direct;}TypeRoate;static TypeRoate _RoateValue={{0,0},0,1};static void SetRotateCenter(int x0,int y0){	_RoateValue.center.x=x0;	_RoateValue.center.y=y0;}static void SetAnggleDir(int direction){	_RoateValue.direct=direction;}#define RADIAN(angle)  ((angle==0)?0:(3.14159*angle/180))static void SetAngle(float angle){	_RoateValue.angle=RADIAN(angle);}static float mySqrt(float x){	float a = x;	unsigned int i = *(unsigned int *)&x;	i = (i + 0x3f76cf62) >> 1;	x = *(float *)&i;	x = (x + a / x) * 0.5;	return x;}//需要优化atant2 cos sin算法#include "math.h"static void Rotate(int x0,int y0,int*x,int*y,double angle,int direction){	//double r=sqrt((*y-y0)*(*y-y0)+(*x-x0)*(*x-x0));	int temp=(*y-y0)*(*y-y0)+(*x-x0)*(*x-x0);	double r=mySqrt(temp);	double a0=atan2(*x-x0,*y-y0);	if(direction)	{		*x=x0+r*cos(a0+angle);		*y=y0+r*sin(a0+angle);	}	else	{		*x=x0+r*cos(a0-angle);		*y=y0+r*sin(a0-angle);		}}static TypeXY GetRotateXY(int x,int y){	TypeXY temp;	int m=x,n=y;//	if(_RoateValue.angle!=0)		Rotate(_RoateValue.center.x,_RoateValue.center.y,&m,&n, _RoateValue.angle ,_RoateValue.direct);	temp.x=m;	temp.y=n;	return temp;}static void MoveTo(int x,int y){	_pointx=x;	_pointy=y;}static void LineTo(int x,int y,uint16_t color){	lcd_DrawLine(_pointx,_pointy,x,y,color);	_pointx=x;	_pointy=y;}//圆弧void lcd_DrawArc(int x,int y,unsigned char r,int angle_start,int angle_end,uint16_t color){	float i=0;	TypeXY m,temp;	temp=GetXY();	SetRotateCenter(x,y);	SetAnggleDir(0);	if(angle_end>360)		angle_end=360;	SetAngle(0);	m=GetRotateXY(x,y+r);	MoveTo(m.x,m.y);	for(i=angle_start;i<angle_end;i+=5)	{		SetAngle(i);		m=GetRotateXY(x,y+r);		LineTo(m.x,m.y,color);	}	LineTo(x+r,y,color);	MoveTo(temp.x,temp.y);}/****************************立方体*****************************/#define DD	18	/* 边长 *//* 立方体各顶点初始坐标 */float lcdcubeinit[8][3] = {	{-DD,-DD,-DD},							{-DD, DD,-DD},							{ DD, DD,-DD},							{ DD,-DD,-DD},							{-DD,-DD, DD},							{-DD, DD, DD},							{ DD, DD, DD},							{ DD,-DD, DD}};/* 立方体各顶点实时坐标 */float lcdcubenew[8][3];	/* 各点连线顺序 */int lcdlineid[24] = {1,2,2,3,3,4,4,1,/*底面*/   5,6,6,7,7,8,8,5,/*顶面*/   8,4,  7,3,  6,2,  5,1/*侧棱*/};	/* 计算旋转后的向量 */float* lmatconv(float pointold[3], float pointnew[3], float spin_matrix[3][3]){	float res[3];		for(int i=0; i<3; i++)	{		res[i]  = 	spin_matrix[i][0]*pointold[0] + 					spin_matrix[i][1]*pointold[1] + 					spin_matrix[i][2]*pointold[2];	}		for(int i=0;i<3;i++)	{		pointnew[i]=res[i]; 	}	return pointnew;}void lrotate(float Cubeinit[][3],float Cubenew[][3],float x,float y,float z){	/* 旋转矩阵 */	float rz[3][3]={{cos(z), -sin(z),   0   },					{sin(z),  cos(z),   0   },					{  0   ,    0   ,   1   }};		float ry[3][3]={{  1,       0  ,    0   },					{  0,    cos(y), -sin(y)},					{  0,    sin(y),  cos(y)}};		float rx[3][3]={{ cos(x),   0,    sin(x)},					{  0    ,   1,       0  },					{-sin(x),   0,    cos(x)}};		/* 旋转向量 */	for(int i=0; i<8; i++)		lmatconv(lmatconv(lmatconv(Cubeinit[i],Cubenew[i],rz),Cubenew[i],ry),Cubenew[i],rx);}float lx=0,ly=0,lz=2;void lloop(uint16_t color){  	ly = 0.3;	lx += 0.2;	lz = 0.3;	/* 坐标偏转更新 */	lrotate(lcdcubeinit,lcdcubenew,lx,ly,lz);		/* 绘制立方体 */	for(int i=0;i<24;i+=2)		lcd_DrawLine(64+lcdcubenew[lcdlineid[i]-1][0],32+lcdcubenew[lcdlineid[i]-1][1],64+lcdcubenew[lcdlineid[i+1]-1][0],32+lcdcubenew[lcdlineid[i+1]-1][1],color);} void lcd_test(uint16_t color){	uint16_t init_fill = INIT_FILL;	int i,j,k;		//图片	lcd_DMAFill(0,0,SCREEN_W,SCREEN_H,&init_fill,DMA_MemoryInc_Disable);	delay_ms(10);	lcd_DMAFill_Picture(0,0,40,40,gImage_1);	delay_ms(1000);	//字符	lcd_DMAFill(0,0,SCREEN_W,SCREEN_H,&init_fill,DMA_MemoryInc_Disable);	delay_ms(10);	lcd_show_str(0,0,SCREEN_W,SCREEN_H,12, (uint8_t *)"ABC",color);	lcd_show_str(0,12,SCREEN_W,SCREEN_H,16,(uint8_t *)"ABC",color);	lcd_show_str(0,28,SCREEN_W,SCREEN_H,24,(uint8_t *)"ABC",color);	delay_ms(2000);	//画线	lcd_DMAFill(0,0,SCREEN_W,SCREEN_H,&init_fill,DMA_MemoryInc_Disable);	delay_ms(10);	for(i=0;i<40;i++)	{		lcd_DrawLine(0,0,i*10,SCREEN_H,color);		delay_ms(100);	}	for(i=0;i<40;i++)	{		lcd_DrawLine(127,0,127-i*10,SCREEN_H,color);		delay_ms(100);	}	delay_ms(1000);	//矩形	lcd_DMAFill(0,0,SCREEN_W,SCREEN_H,&init_fill,DMA_MemoryInc_Disable);	delay_ms(10);	for(j=0;j<2;j++)	{		for(i=0;i<31;i+=2)		{			lcd_DrawRect((i+j)*2,(i+j),127-(i+j)*4,63-2*(i+j),color);			delay_ms(100);		}	}	delay_ms(1000);	//圆角矩形	lcd_DMAFill(0,0,SCREEN_W,SCREEN_H,&init_fill,DMA_MemoryInc_Disable);	delay_ms(10);	for(i=0;i<31;i+=2)	{		lcd_DrawRoundRect((i)*2,i,128-i*4,64-2*i,10,color);		delay_ms(100);	}	delay_ms(1000);	//椭圆	lcd_DMAFill(0,0,SCREEN_W,SCREEN_H,&init_fill,DMA_MemoryInc_Disable);	delay_ms(10);	lcd_DrawEllipse(63,31,63,31,color);	delay_ms(1000);	lcd_DMAFill(0,0,SCREEN_W,SCREEN_H,&init_fill,DMA_MemoryInc_Disable);	delay_ms(10);	lcd_DrawEllipse(63,31,16,31,color);	delay_ms(1000);	//圆	lcd_DMAFill(0,0,SCREEN_W,SCREEN_H,&init_fill,DMA_MemoryInc_Disable);	delay_ms(10);	lcd_DrawCircle(63,31,30,color);	delay_ms(1000);	//三角形	lcd_DMAFill(0,0,SCREEN_W,SCREEN_H,&init_fill,DMA_MemoryInc_Disable);	delay_ms(10);	lcd_DrawTriangle(5,10,100,30,60,50,color);	delay_ms(1000);	//圆弧	lcd_DMAFill(0,0,SCREEN_W,SCREEN_H,&init_fill,DMA_MemoryInc_Disable);	delay_ms(10);	k = getsystick_us();	for(i=0;i<360;i++)	{		lcd_DrawArc(63,31,30,0,i,color);		delay_ms(1);	}	k = getsystick_us()-k;	lcd_show_num(0,0,16,k,0,color);	delay_ms(1000);	for(i=0;i<40;i++)	{		lloop(color);		delay_ms(50);	}	delay_ms(2000);}