/* * STM32F103C8T6 * FLASH : 64K * RAM   : 20K */  /* * 由于Cortex规定从0x00000000取栈顶值，然后执行0x00000004的内容 * 因ST将闪存起始地址0x08000000映射到了0x00000000，故从0x00000000与从0x08000000开始执行是一致的 * stm32通过配置boot脚，有三种启动模式选择，这三种模式的本质就是将对应区域重映射为0x00000000地址 * 将代码放置在闪存的其他地址，实际还是从0x00000000开始执行的 * * 当来一个中断时，cpu就会从0x00000000+<向量表偏移值>位置找到中断向量表，然后再查表跳转到对应的中断服务函数去执行 * 可以容纳多个向量表，只需通过VTOR指定你所需的向量表位置即可，故在跳转到APP程序后的首要任务是重定位向量表位置， * 以便执行当前程序的向量表来查找对应中断服务函数 * 关于中断向量表的重置，看https://www.eemaker.com/stm32-iap-vtor.html */  /*  * 自动生成.bin文件方法：在"option for target"user页面的after build/rebuild中填入：  * fromelf.exe --bin -o "$L@L.bin" "#L"  */  #include "delay.h"#include "led.h"#include "flash.h"/* APP Jump address */#define JUMP_ADDR	0x08003000typedef void (*jump_Fun)(void);jump_Fun jump2App;__asm void Set_MSP(u32 val){	MSR MSP, r0	BX lr}#define JUMP_TAST_ON#define PT_TEST/***********************************************//***********************************************//***********************************************/#ifdef PT_TEST#define PT_INIT(x)	( x = 0 )#define PT_START(x)	\	switch(x) 		\	{ 				\		case 0: #define PT_YIELD(x, re_val)	\		do{						\			x = __LINE__;		\			return (re_val);	\			case __LINE__ :{} 	\		}while(0);#define PT_WAITUNTIL(x,condition,re_val)	\		do{ 								\			x = __LINE__; 					\			case __LINE__ :; 				\			if(!condition) 					\				return (re_val);			\		}while(0);#define PT_END(x) \	}	/* Protothreads example */\uint8_t i=0,state=0;uint8_t function(void){#if 1	switch(state)	{		case 0:			for (i = 0; i < 10; i++)			{				state = __LINE__ + 2;				return i;				case __LINE__:;			}	}#else	PT_START(&state);/* start of function */	{		for (i = 0; i < 10; i++) 			PT_YIELD(&state,i);	}	PT_END(&state);#endif		return 0;}uint32_t jump_cnt;uint8_t jump(uint32_t state){	PT_START(state);	{		PT_WAITUNTIL(state, (jump_cnt>20), 0);				//close clk		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,DISABLE);				Set_MSP(*(u32 *)JUMP_ADDR);		jump2App = (jump_Fun)(*(u32 *)(JUMP_ADDR + 4));		jump2App();	}	PT_END(state);		return 0;}#endif/***********************************************//***********************************************//***********************************************/uint32_t cnt = 0;int main(void){	#ifdef PT_TEST		uint32_t PT_state;		PT_INIT(PT_state);	#endif		delay_init();	led_init();		while(1)	{	#ifdef JUMP_TAST_ON		#ifdef PT_TEST			delay_ms(100);			((cnt++)%2 == 0) ? led_state(1) : led_state(0);						jump_cnt++;			jump(PT_state);		#else			delay_ms(100);			(cnt%2 == 0) ? led_state(1) : led_state(0);						//boot			if(++cnt >= 15)			{				//close clk				RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,DISABLE);								Set_MSP(*(u32 *)JUMP_ADDR);				jump2App = (jump_Fun)(*(u32 *)(JUMP_ADDR + 4));				jump2App();			}		#endif	#endif	}}